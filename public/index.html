<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RAG + Ollama Chat (SSE)</title>
    
    <!-- Markdown 파서 -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- XSS 방지 Sanitizer -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <!-- (선택) 코드 하이라이트 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>

    <style>
        body { font-family: ui-sans-serif, system-ui, -apple-system; margin:0; background:#f6f7f9; }
        .wrap { max-width: 860px; margin: 40px auto; background: #fff; border-radius: 14px; box-shadow: 0 6px 18px rgba(0,0,0,.08); overflow: hidden; }
        header { padding: 16px 20px; font-weight: 700; border-bottom: 1px solid #eee; display:flex; gap:12px; align-items:center; }
        header input, header select { padding:8px 10px; border:1px solid #ddd; border-radius:8px; }
        #chat { padding: 20px; height: 64vh; overflow: auto; }
        .msg { margin: 10px 0; line-height: 1.55; }
        .user { text-align: right; }
        .bubble.ai p { margin: .4em 0; }
        .bubble.user { background:#2563eb; color:white; }
        .bubble.ai {
            background:#f1f5f9;
            color:#111827;
            padding: 10px 16px;
            border-radius: 16px 16px 16px 4px;
            display: inline-block;
            max-width: 70%;
            min-width: 80px;
            width: fit-content;
            word-break: break-word;
        }
        .bubble.user {
            background:#2563eb;
            color:white;
            padding: 10px 16px;         /* ⬅ 여백 조금 더 주기 */
            border-radius: 16px 16px 4px 16px; /* ⬅ 모서리도 둥글게 */
            display: inline-block;
            max-width: 70%;             /* ⬅ 화면 차지 최대폭 (가변) */
            min-width: 80px;            /* ⬅ 너무 좁아지지 않도록 최소폭 */
            width: fit-content;         /* ⬅ 내용 길이에 맞게 자동 조절 */
            word-break: break-word;     /* ⬅ 긴 단어 줄바꿈 */
            overflow-wrap: anywhere;           /* 긴 숫자/URL도 줄바꿈 */
        }
        .msg.user .bubble { margin-right: auto; }    /* ⬅ 사용자 입력 텍스트의 정렬 */
        .msg.ai   .bubble { margin-right: auto; }    /* ⬅ ai 출력 텍스트의 정렬 */
        form { display:flex; gap:8px; padding: 12px; border-top:1px solid #eee; background:#fafafa; }
        input[type="text"], button, select { font-size: 16px; padding: 10px; border-radius: 10px; border: 1px solid #ddd; }
        input[type="text"] { flex:1; }
        button { background:#111827; color:white; cursor:pointer; }
        button:disabled { opacity:.6; cursor:not-allowed; }

        /* 물결(Wave) 로딩 애니메이션: 텍스트에 움직이는 그라디언트 */
        .wave {
            display:inline-block;                /* 텍스트 폭만큼만 배경 적용 */
            background: linear-gradient(90deg, rgba(0,0,0,0.15), rgba(0,0,0,0.35), rgba(0,0,0,0.15));
            background-size:200% 100%;
            -webkit-background-clip:text;       /* 크롬/엣지/사파리 */
            background-clip:text;
            color:transparent;                   /* 파이어폭스 */
            -webkit-text-fill-color:transparent; /* 크롬/엣지/사파리 - 중요! */
            animation:waveSlide 1.2s linear infinite;
        }
        @keyframes waveSlide {
            0% { background-position: 200% 0 }
            100% { background-position: 0% 0 }
        }

        .bubble p { margin: .25em 0; }
        .bubble p:first-child { margin-top: 0; }
        .bubble p:last-child  { margin-bottom: 0; }

        .bubble.ai pre {
            background: #0f172a0d;  /* 아주 옅은 배경 */
            padding: 10px 12px;
            border-radius: 10px;
            overflow: auto;
        }
        .bubble.ai code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            font-size: 0.95em;
        }
        .bubble.ai table {
            border-collapse: collapse;
            border: 1px solid #e5e7eb;
        }
        .bubble.ai table th, .bubble.ai table td {
            border: 1px solid #e5e7eb;
            padding: 6px 8px;
        }
        .bubble.ai ul, .bubble.ai ol { padding-left: 1.25em; }
        /* 말풍선 안 리스트 간격 줄이기 */
        .bubble.ai ul { margin: .3em 0; padding-left: 1.2em; }
        .bubble.ai li { margin: .15em 0; }
        .bubble.ai p { margin: .4em 0; }
        .bubble .md { white-space: normal; }
    </style>
</head>
<body>
    <div class="wrap">
        <header>
            <div>RAG + Ollama Chat (SSE)</div>
            <select id="model">
            <option value="llama3.1" selected>llama3.1</option>
            <option value="mistral">mistral</option>
            <option value="gemma">gemma</option>
            </select>
            <input id="server" value="http://127.0.0.1:8000" title="FastAPI 서버 주소" />
        </header>
        <div id="chat"></div>
        <form id="composer">
            <input id="input" type="text" placeholder="질문을 입력하세요…" autocomplete="off" />
            <button type="submit">Send</button>
        </form>
    </div>

    <script>
        const chatEl = document.getElementById('chat');
        const form = document.getElementById('composer');
        const input = document.getElementById('input');
        const modelSel = document.getElementById('model');
        const serverInput = document.getElementById('server');

        // 대화 히스토리 (서버로 함께 전송)
        const history = [];
        let currentES = null;

        /* ========= Helpers ========= */

        // 숫자처럼 보이는지(표 헤더 판별에 사용)
        function looksNumeric(t) {
            return /^[\d,\.\-\s%]+$/.test(t) && !/[A-Za-z가-힣]/.test(t);
        }

        // 셀 정리
        function normCell(t) {
            return t.replace(/\s+/g, " ").trim();
        }

        // 한 줄(또는 연속 블록)로 붙은 파이프 데이터를 마크다운 표로 재구성
        function rebuildPipeBlock(block) {
            // "||"로 줄 바꿈해 온 경우 보정
            block = block.replace(/\|\|/g, "|\n|").replace(/\r?\n/g, "");

            const tokens = block
                .split("|")
                .map(normCell)
                .filter(Boolean);

            let out = [];
            let i = 0;

            while (i < tokens.length) {
                let best = null; // {m, rows, score}
                for (let m = 2; m <= 10; m++) {
                    const remain = (tokens.length - i) % m;
                    const rows = Math.floor((tokens.length - i) / m);
                    if (rows < 2) continue;

                    const header = tokens.slice(i, i + m);
                    const nonNum = header.filter(t => !looksNumeric(t)).length;

                    // 잔여 0, 헤더 비숫자 많음, 행수 많음에 가점
                    const score = (remain === 0 ? 100 : 50 - remain) + nonNum * 2 + rows;
                    if (!best || score > best.score) best = { m, rows, score };
                }

                if (!best) {
                    out.push(tokens.slice(i).join(" | "));
                    break;
                }

                const { m, rows } = best;
                let tableLines = [];
                for (let r = 0; r < rows; r++) {
                    const row = tokens.slice(i + r * m, i + (r + 1) * m);
                    tableLines.push("|" + row.join("|") + "|");
                }
                const sep = "|" + Array(m).fill("---").join("|") + "|";
                tableLines.splice(1, 0, sep);
                out.push(tableLines.join("\n"));
                i += rows * m;
            }

            return "\n" + out.join("\n\n") + "\n";
        }

        /* ========= Main ========= */

        function preprocessMarkdown(md, {
            sentenceSpace = true, // 마침표/물음표/느낌표 뒤 "공백"만 보장
            bulletBreak   = true, // 불릿이 문장 뒤에 붙어오면 줄바꿈
            numberList    = true, // "1. " 같은 번호 목록 보정
            keepUnits     = true, // '원/만원/%/억' 뒤 개행 금지
            fixTables     = true, // 인라인 파이프 표 재구성
            maxBlank      = 2     // 연속 빈 줄 최대
        } = {}) {
            if (!md) return "";
            md = String(md).replace(/\r\n?/g, "\n").replace(/\t/g, " ");

            /* 0) 코드 블록/인라인 보호 */
            const stash = [];
            md = md.replace(/```([\s\S]*?)```/g, (m) => {
                const k = `__FENCE_${stash.length}__`;
                stash.push({ k, m });
                return k;
            });
            md = md.replace(/`([^`]+)`/g, (m) => {
                const k = `__CODE_${stash.length}__`;
                stash.push({ k, m });
                return k;
            });

            /* 1) 숫자 포맷 보정 (chunk로 쪼개진 것들 복원) */
            // 소수점: "84. 9251" -> "84.9251"
            md = md.replace(/(\d+)\s*\.\s*(\d+)/g, "$1.$2");
            // 천단위 쉼표: "225, 626, 000" -> "225,626,000"
            md = md
                .replace(/(\d)\s+,/g, "$1,")               // 숫자+공백+콤마 -> 숫자+콤마
                .replace(/,(\s+)(\d{3}\b)/g, ",$2");       // 콤마 뒤 공백 제거(3자리 그룹)

            /* 2) 굵게(**…**) 안/주변 줄바꿈 제거 */
            md = md.replace(/\*\*\s*([\s\S]*?)\s*\*\*/g, (_, inner) => `**${inner.replace(/\s+/g, " ").trim()}**`);

            /* 3) 인라인 표 재구성 */
            if (fixTables) {
                // 파이프가 다수 포함된 "한 줄"을 표 후보로 간주
                md = md.replace(
                    /(?:^|\n)([^ \n]*\|[^ \n]*\|[^ \n]*\|[^ \n]*\|[^ \n]*[^ \n|]*)(?=\n|$)/g,
                    (m, block) => {
                        const pipes = (block.match(/\|/g) || []).length;
                        if (pipes < 5) return m;       // 파이프가 적으면 무시
                        return rebuildPipeBlock(block);
                    }
                );
            }

            /* 4) 단위 뒤 개행 금지 (원/만원/억/%) */
            if (keepUnits) {
                md = md.replace(/(원|만원|억|%)[ \t]*\n[ \t]*/g, "$1 ");
            }

            /* 5) 마침표/느낌표/물음표 뒤는 "공백"만 보장 (줄바꿈 X)
                    - 소수점(숫자.숫자)은 제외, 이미 공백/개행/문장기호면 건드리지 않음 */
            if (sentenceSpace) {
                md = md
                .replace(/(?<!\d)\.(?=[^\d\s.!?:;])/g, ". ") // 숫자 아닌 마침표 뒤 공백
                .replace(/([!?])(?![\s.!?:;])/g, "$1 ");     // !? 뒤 공백
            }

            /* 6) 불릿/번호 목록이 문장 뒤에 붙어오면 줄바꿈 */
            if (bulletBreak) {
                md = md.replace(/([^\n])\s*([\-*•·–]\s+)/g, "$1\n$2");
            }
            if (numberList) {
                md = md
                    .replace(/([^\n])\s*(\d{1,3}\.\s+)/g, "$1\n$2")
                    .replace(/([^\n])\s*(\d{1,3}\)\s+)/g, "$1\n$2")
                    .replace(/([^\n])\s*(\(\d{1,3}\)\s+)/g, "$1\n$2");
            }

            /* 7) 과도한 공백/개행 정리 (쉼표 뒤 개행은 절대 만들지 않음) */
            md = md
                .replace(/[ \t]+\n/g, "\n")                            // 줄 끝 공백 제거
                .replace(/\n{2,}([\-*•·–]\s)/g, "\n$1")                // 리스트 사이 과개행 축약
                .replace(new RegExp(`\\n{${maxBlank + 1},}`, "g"), "\n".repeat(maxBlank))
                .trim();

            /* 8) 보호했던 코드 복원 */
            for (const f of stash) md = md.replace(f.k, f.m);

            return md;
        }


        // 마크다운 → 안전한 HTML로 렌더
        function renderMarkdown(md, el) {
            marked.setOptions({
                gfm: true,
                breaks: true,          // 단일 개행도 <br>로
                mangle: false,
                headerIds: false
            });

            const html = marked.parse(preprocessMarkdown(md) || "");
            const safe = DOMPurify.sanitize(html);
            el.innerHTML = safe;

            // 링크 새창
            el.querySelectorAll('a[href]').forEach(a => {
                a.setAttribute('target', '_blank');
                a.setAttribute('rel', 'noopener noreferrer');
            });

            // 코드 하이라이트
            el.querySelectorAll('pre code').forEach(block => {
                try { hljs.highlightElement(block); } catch {}
            });
        }

        function addBubble(role, text) {
            const row = document.createElement('div');
            row.className = 'msg ' + (role === 'user' ? 'user' : 'ai');

            const bubble = document.createElement('div');
            bubble.className = 'bubble ' + (role === 'user' ? 'user' : 'ai');

            // 여기만 변경: 처음부터 마크다운 렌더 가능
            //renderMarkdown(text, bubble);

            // 🔹 마크다운 전용 컨테이너
            const md = document.createElement('div');
            md.className = 'md';
            bubble.appendChild(md);

            // 사용자 메시지나 초기 텍스트가 있을 때만 렌더
            if (role === 'assistant' && (text === '' || text == null)) {
                // 아무것도 그리지 않음 (로더가 들어올 자리)
            } else {
                renderMarkdown(text ?? '', md);
            }

            row.appendChild(bubble);
            chatEl.appendChild(row);
            chatEl.scrollTop = chatEl.scrollHeight;
            return bubble;
        }

        function closeSSE(es) {
            if (es && es.readyState !== EventSource.CLOSED) {
                es.close();
            }
        }

        function clearWave(e1) {
            if (!e1) return;              // 방어
            const w = e1.querySelector('.wave');
            if (w) w.remove();
        }

        async function sendMessage(userText) {
            // 화면 & 히스토리 반영
            addBubble('user', userText);
            history.push({ role: 'user', content: userText });

            // 새로 열기 전에 항상 이전 연결 정리
            if (currentES) { closeSSE(currentES); currentES = null; }

            // 스트리밍 상태 변수는 최상단에 선언(호이스팅/TDZ 회피)
            let gotAny = false;
            let started = false;
            let aiMd = "";
            let timeoutId = null;      // 먼저 선언 (핸들러에서 참조 가능)

            // SSE용 타이핑 wave 버블
            const aiBubble = addBubble('assistant', ''); // 비워서 생성
            //aiBubble.innerHTML = '<span class="wave">답변 생성 중…</span>';
            const mdEl = aiBubble.querySelector('.md');  // 🔹 마크다운 전용 엘리먼트
            const loader = document.createElement('span');  // 로더 엘리먼트
            loader.className = 'wave';
            loader.textContent = '답변 생성 중…';
            aiBubble.appendChild(loader);

            const server = serverInput.value.replace(/\/$/, '');
            const sid = Date.now().toString(36) + Math.random().toString(36).slice(2);
            const qs = new URLSearchParams({
                query: userText,
                model: modelSel.value,
                history: JSON.stringify(history),
                sid,
            });
            const url = `${server}/api/chat_sse?${qs.toString()}`;

            // EventSource 시작
            let es;
            try {
                es = new EventSource(url);
                currentES = es;
                
                // 생성 직후, 가장 먼저 핸들러를 붙인다
                // 여기서부터만 ev 사용 (이벤트 리스너 내부!)
                es.addEventListener('message', (ev) => {
                    console.log('[SSE message]', ev.data); // log 추가 (2025. 8. 24.)
                    if (!ev.data) return;
                    gotAny = true;

                    if (!started) {
                        started = true;
                        aiMd = ev.data;
                        // 로딩만 제거 후 실제 마크다운 렌더 (말풍선 비우지 않음)
                        clearWave(aiBubble);
                        //renderMarkdown(aiMd, aiBubble);
                        renderMarkdown(aiMd, mdEl);   // 🔹 md 컨테이너에만 렌더
                    } else {
                        aiMd += ev.data;
                        //renderMarkdown(aiMd, aiBubble);
                        renderMarkdown(aiMd, mdEl);   // 🔹 md 컨테이너에만 렌더
                    }
                    chatEl.scrollTop = chatEl.scrollHeight;
                });

                es.addEventListener('model_error', (ev) => {
                    clearTimeout(timeoutId);
                    closeSSE(es); if (currentES === es) currentES = null;
                    clearWave(aiBubble);
                    aiMd = `**[모델 오류]** ${ev?.data || ''}`;
                    //renderMarkdown(aiMd, aiBubble);
                    renderMarkdown(aiMd, mdEl);
                    history.push({ role: 'assistant', content: aiMd });
                });

                es.addEventListener('done', () => {
                    clearTimeout(timeoutId);
                    closeSSE(es); if (currentES === es) currentES = null;
                    clearWave(aiBubble);
                    //renderMarkdown(aiMd || "[응답 없음]", aiBubble);
                    renderMarkdown(aiMd || "[응답 없음]", mdEl);
                    history.push({ role: 'assistant', content: aiMd });
                });

                // 네트워크/HTTP 오류(4xx/5xx 포함) → 자동 재연결이 계속되면 “무한 루프처럼” 보임
                es.onerror = () => {
                    clearTimeout(timeoutId);
                    closeSSE(es); if (currentES === es) currentES = null;
                    clearWave(aiBubble);
                    if (!gotAny) {
                        aiMd = "**[SSE 오류]** 연결이 끊겼습니다.";
                        //renderMarkdown(aiMd, aiBubble);
                        renderMarkdown(aiMd, mdEl);
                        history.push({ role: 'assistant', content: aiMd });
                    }
                    // EventSource는 기본적으로 재연결 시도 → close로 반드시 끊어줌
                };

                // 리스너 부착 완료를 서버에 통지 (핸드셰이크)
                try {
                    const resp = await fetch(`${server}/api/sse_ready`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sid }),
                    });

                    if (!resp.ok) {
                        console.error('[sse_ready] HTTP', resp.status);
                    } else {
                        const jr = await resp.json().catch(()=>({}));
                        if (!jr.ok) console.error('[sse_ready] resp', jr);
                    }
                } catch (e) {
                    console.error('[sse_ready] failed', e);
                }
            } catch (e) { 
                clearWave(aiBubble);
                //renderMarkdown("**[SSE 생성 실패]** " + (e?.message || e), aiBubble);
                renderMarkdown("**[SSE 생성 실패]** " + (e?.message || e), mdEl);
                history.push({ role: 'assistant', content: aiBubble.textContent });
                return;
            }

            // 60초 타임아웃 보호장치
            timeoutId = setTimeout(() => {
                closeSSE(es);
                if (currentES === es) currentES = null;
                //aiBubble.classList.remove('wave');
                clearWave(aiBubble);
                //renderMarkdown("**[타임아웃]** 서버 응답이 없습니다.", aiBubble);
                renderMarkdown("**[타임아웃]** 서버 응답이 없습니다.", mdEl);
                history.push({ role: 'assistant', content: aiBubble.textContent });
            }, 60000);
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const text = input.value.trim();
            if (!text) return;
            input.value = '';
            form.querySelector('button').disabled = true;
            try {
                await sendMessage(text);
            } finally {
                form.querySelector('button').disabled = false;
                input.focus();
            }
        });
    </script>
</body>
</html>